<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KeepUp&#39;s Blog">
<meta property="og:url" content="https://caixiaobai.github.io/page/2/index.html">
<meta property="og:site_name" content="KeepUp&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KeepUp&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://caixiaobai.github.io/page/2/">





  <title>KeepUp's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KeepUp's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/05/14/剑指Offer——旋转数组的最小数字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/剑指Offer——旋转数组的最小数字/" itemprop="url">剑指Offer——旋转数组的最小数字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-14T09:54:00+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指Offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指Offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>时间限制：3秒 空间限制：32768K</p>
<p>本题知识点： 查找</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line">        if(array.length &lt;=0 )&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(array.length == 1)&#123;</span><br><span class="line">            return array[0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; array.length - 1; i++)&#123;</span><br><span class="line">            if(array[i] &lt; array[i -1])&#123;</span><br><span class="line">                return array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if(array[array.length - i] &lt; array[array.length - i -1])&#123;</span><br><span class="line">                return array[array.length - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>旋转后的数组有前后两个有序的片段组成，两个片段中，前一个元素都小于等于后一个元素。前一个片段的所有元素都大于等于后一个片段的元素，所以我们要找的就是两个元素的分界点，然后取后一个片段的第一个元素即为最小值。</p>
<p>我们可以从数组的头和尾同时查找，从头的开始的如果后一个元素小于前一个元素，那么后一个元素就是最小值；从尾开始的如果后一个元素小于前一个元素，那么后一个元素即为最小值。</p>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/05/14/剑指Offer——二进制中-1-的个数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/剑指Offer——二进制中-1-的个数/" itemprop="url">剑指Offer——二进制中 1 的个数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-14T09:50:00+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指Offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指Offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>时间限制：1秒 空间限制：32768K</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while(n!=0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n&amp;(n-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们先来看一个数的二进制，就比如 12 的二进制表示是 1100 ，如果一个整数不等于 0 的话，那么至少有一位是 1。如果我们把这个整数减 1 ，也就是 11 的二进制是 1011，我们发现原来整数的最右边的 1 就会变成 0 ，而原来 1 后边的所有 0 都会变成 1 （如果原来 1 后边有 0 的话），原来 1 前边的将不变。</p>
<p>也就是说把一个整数减 1 之后，得到的结果就是把原来整数从最右边的 1 开始的所有位都做了取反操作，然后再把原来的整数和减 1 之后的数做与运算，即从原来数的最右边的 1 开始所有位都变成了 0 。比如： 1100&amp;1011=1000，也就是说把一个数减 1 再与原来的数做与运算，就是把原来数的最右边的 1 变成了 0，那么我们可以对一个二进制的整数进行多少次这样的运算，就表示这个整数的二进制中有多少个 1 。</p>
<h4 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题"></a>延伸问题</h4><ul>
<li><p>与运算（&amp;）</p>
<p>运算规则：1&amp;0=0；0&amp;1=0；0&amp;0=0；1&amp;1=1。</p>
<p>两位同时为 1 ，结果才为 1，否则为 0。</p>
</li>
<li><p>或运算（|）</p>
<p>运算规则：1|0=1；0|1=1；0|0=0；1|1=1。</p>
<p>只要有一个为 1 ，那么结果就为 1。</p>
</li>
<li><p>异或运算（^）</p>
<p>运算规则：1\^0=1；0\^1=1；0\^0=0；1\^1=0；</p>
<p>如果两个相应位为“异”（值不同），则该位结果为 1，否则为 0。</p>
</li>
<li><p>取反运算（~）</p>
<p>运算规则：~1=0；~0=1；</p>
<p>对一个二进制数按位取反，即将 0 变 1，1 变 0。</p>
</li>
<li><p>左移运算（&lt;&lt;）</p>
<p>将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p>
<p>例如：a=a&lt;&lt;2，将 a 的二进制位左移两位，右边补 0。</p>
<p>若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2，即 a=a*2。</p>
</li>
<li><p>右移运算（&gt;&gt;）</p>
<p>将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。</p>
<p>例如：a = a&gt;&gt; 2，将 a 的二进制位右移 2 位。</p>
<p>每右移一位，相当于该数除以2。</p>
</li>
</ul>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/05/11/Mac-下-Centos7-Minimal-版本虚拟机软件安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/Mac-下-Centos7-Minimal-版本虚拟机软件安装/" itemprop="url">Mac-下-Centos7-Minimal-版本虚拟机软件安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-11T20:54:00+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="下载-Centos7-ISO-文件"><a href="#下载-Centos7-ISO-文件" class="headerlink" title="下载 Centos7 ISO 文件"></a>下载 Centos7 ISO 文件</h5><p>官方下载地址：<a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso" target="_blank" rel="noopener">http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>使用 VMWare 虚拟机方式安装，安装过程很简单，不详细说了</p>
<h5 id="yum-安装-ifconfig-工具"><a href="#yum-安装-ifconfig-工具" class="headerlink" title="yum 安装 ifconfig 工具"></a>yum 安装 ifconfig 工具</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install net-tools.x86_64</span><br></pre></td></tr></table></figure>
<h5 id="安装-VIM-工具"><a href="#安装-VIM-工具" class="headerlink" title="安装 VIM 工具"></a>安装 VIM 工具</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim</span><br></pre></td></tr></table></figure>
<h5 id="安装-wget-工具"><a href="#安装-wget-工具" class="headerlink" title="安装 wget 工具"></a>安装 wget 工具</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>
<h5 id="修改网络配置"><a href="#修改网络配置" class="headerlink" title="修改网络配置"></a>修改网络配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static                # 设置为静态</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes                      # 开机启用</span><br><span class="line">IPADDR=xxx.xxx.xxx.xxx          # ip地址</span><br><span class="line">GATEWAY=xxx.xxx.xxx.xxx         # 网关</span><br><span class="line">NETMASK=xxx.xxx.xxx.xxx         # 子网掩码</span><br><span class="line">DNS=xxx.xxx.xxx.xxx             # DNS</span><br></pre></td></tr></table></figure>
<p>修改图中标记的几项，ip地址、网管和 DNS 根据自己情况修改<br>然后重启网卡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></p>
<h5 id="禁用防火墙"><a href="#禁用防火墙" class="headerlink" title="禁用防火墙"></a>禁用防火墙</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld    //禁用防火墙</span><br><span class="line">systemctl disable firewalld //关闭防火墙开机自启动</span><br></pre></td></tr></table></figure>
<h5 id="设置SELinux执行模式"><a href="#设置SELinux执行模式" class="headerlink" title="设置SELinux执行模式"></a>设置SELinux执行模式</h5><ul>
<li>检查SELinux模式：getenforce，如果输出permissive或者disabled，你可以跳过该步骤，如果输出enforcing，则需要继续下面的操作步骤。</li>
<li>编辑/etc/selinux/config（在某些操作系统可能是/etc/sysconfig/selinux）文件，将SELINUX=enforcing修改为SELINUX=permissive，保存该文件。</li>
<li>重启操作系统生效或者执行：setenforce 0临时禁用SELinux。</li>
</ul>
<h5 id="修改-hostname"><a href="#修改-hostname" class="headerlink" title="修改 hostname"></a>修改 hostname</h5><ul>
<li>编辑 /etc/sysconfig/network 文件，添加 <strong>NETWORKING=yes</strong> 和 <strong>HOSTNAME=hostname</strong> 两项，保存</li>
<li>编辑 /etc/hosts 文件，添加 <strong>172.16.155.130 hostname</strong>，保存文件</li>
<li>hostnamectl set-hostname hostname</li>
</ul>
<h5 id="安装-VMWare-Tools"><a href="#安装-VMWare-Tools" class="headerlink" title="安装 VMWare Tools"></a>安装 VMWare Tools</h5><ul>
<li>首先关掉虚拟机</li>
<li>选择虚拟机设置-&gt;CD/DVD-&gt;取消勾选 连接CD/DVD驱动器</li>
<li>重新开启虚拟机</li>
<li>安装编译需要的包 <strong>yum install gcc  kernel-headers kernel-devel</strong></li>
<li>创建挂载目录 <strong>mkdir /mnt/cdrom</strong></li>
<li>将光驱挂载到/mnt/cdrom目录 <strong>mount /dev/cdrom /mnt/cdrom</strong></li>
<li>然后选择 虚拟机-&gt;安装 VMware Tools</li>
<li>进入到挂载目录 <strong>cd /mnt/cdrom</strong></li>
<li>拷贝安装包 <strong>cp VMwareTools-xxx.tar.gz /usr/local/src/</strong></li>
<li>进入拷贝目录并解压 <strong>cd /usr/local/src/</strong>  解压：<strong>tar -zxvf VMwareTools-xxx.tar.gz</strong></li>
<li>进入解压文件夹 <strong>cd vmware-tools-distrib/</strong></li>
<li>安装 <strong>./vmware-install.pl</strong></li>
<li>然后一路根据提示 yes 回车即可</li>
<li>在VM的状态栏上选择-&gt;虚拟机-&gt;设置-&gt;共享，创建共享文件夹</li>
<li>然后进入到 /mnt/hgfs/ 就可以看到设置的共享文件夹了</li>
</ul>
<blockquote>
<p>安装过程遇到的问题</p>
<p>Searching for GCC…<br>The path “” is not valid path to the gcc binary.<br>Would you like to change it? [yes]<br>如果出现这个就表明gcc没有安装，结束安装过程，然后安装 gcc<br><strong>yum install gcc gcc-c++ automake make</strong><br>Searching for a valid kernel header path…<br>The path “” is not a valid path to the 3.10.0327.el7.x86_64 kernel headers.<br>Would you like to change it? [yes]<br>如果遇到这个问题，表示没有安装 kernel ，结束安装过程，然后安装 kernel<br><strong>yum -y install kernel-devel-$(uname -r)</strong></p>
</blockquote>
<h5 id="安装-jdk1-8"><a href="#安装-jdk1-8" class="headerlink" title="安装 jdk1.8"></a>安装 jdk1.8</h5><ul>
<li>去官网下载 jdk 的 tar.gz 的安装包</li>
<li>解压 tar -zxvf jdk-8u171-linux-x64.tar.gz</li>
<li><p>添加环境变量，<strong>vim ~/.bashrc</strong>，然后添加</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/src/jdk1.8.0_171</span><br><span class="line">export JRE_HOME=/usr/local/src/jdk1.8.0_171/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>使环境变量生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># java -version</span><br><span class="line">java version &quot;1.8.0_171&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h5><p>接下来我们使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line">rem -ivh mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line">yum update</span><br><span class="line">yum install mysql-server</span><br></pre></td></tr></table></figure></p>
<p>设置权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown mysql:mysql -R /var/lib/mysql</span><br></pre></td></tr></table></figure></p>
<p>查看 root 密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br></pre></td></tr></table></figure></p>
<p>启动 mysql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure></p>
<p>登录 mysql，密码为找到的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></p>
<p>修改密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for root@localhost = &apos;123&apos;;</span><br></pre></td></tr></table></figure></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://stackoverflow.com/questions/33510184/change-mysql-root-password-on-centos7/34207996#34207996" target="_blank" rel="noopener">https://stackoverflow.com/questions/33510184/change-mysql-root-password-on-centos7/34207996#34207996</a><br><a href="https://www.linuxquestions.org/questions/linux-newbie-8/mysqld_safe-command-not-found-4175642427/" target="_blank" rel="noopener">https://www.linuxquestions.org/questions/linux-newbie-8/mysqld_safe-command-not-found-4175642427/</a><br><a href="https://www.staroon.dev/2017/11/05/SetEnv/#JDK1-8安装" target="_blank" rel="noopener">https://www.staroon.dev/2017/11/05/SetEnv/#JDK1-8安装</a><br><a href="https://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-install.html</a><br><a href="https://blog.csdn.net/li_001/article/details/53171037" target="_blank" rel="noopener">https://blog.csdn.net/li_001/article/details/53171037</a><br><a href="https://blog.51cto.com/wutou/1733378" target="_blank" rel="noopener">https://blog.51cto.com/wutou/1733378</a><br><a href="https://www.jianshu.com/p/5290ad7d6bd3" target="_blank" rel="noopener">https://www.jianshu.com/p/5290ad7d6bd3</a></p>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/04/13/数据结构与算法系列——递归/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/数据结构与算法系列——递归/" itemprop="url">数据结构与算法——递归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-13T17:13:00+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="递归的理解"><a href="#递归的理解" class="headerlink" title="递归的理解"></a>递归的理解</h3><p>在学习数据结构和算法的过程中，递归可能是比较难理解的一个知识点，每次都试着用自己的大脑去把一步一步去想清楚，结果最后把自己都绕晕了。</p>
<p>我们很多人都遇到过这种情况，读源码的时候，我们想弄清楚一个方法的具体实现，然后跟进去发现里边还有一个方法，然后我们又跟到新的方法里边，结果发现里边还有另一个新的方法……这样跟了一层又一层，终于到了最后一层没有再调用其他的方法，然后我们再一层一层返回去，最终弄明白了最初想了解的方法的作用（实际中这种方式是不推荐的，因为嵌套很多层，最后搞得头都大了，却忘记了最初是要干什么）。其实这就是一个递归的过程，通过一层一层的去了解方法的作用，然后到最后再一层一层返回去，明白最初方法的作用。</p>
<p>到这里，我想大家其实对递归也有一定了解了。其实递归就是可以把原来一个大型复杂的任务，分解成一个或几个与原任务有相类似求解方法的小任务，然后最后有一个终止条件。</p>
<h3 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h3><p>由此我们可以总结出几个使用递归需要满足的条件：</p>
<ul>
<li>一个问题可以分解为一个或几个子问题</li>
<li>子问题和原来问题的求解方式相同，只是规模比原问题小</li>
<li>存在终止条件，否则会变成无限循环</li>
</ul>
<h3 id="举一个例子"><a href="#举一个例子" class="headerlink" title="举一个例子"></a>举一个例子</h3><p>前几天刷剑指offer题库，碰到了好多题都可以用递归的方法计算。比如其中一个经典的跳台阶问题。</p>
<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>每次跳台阶都有两个选择，要么跳1级，要么跳2级。只有1级台阶的时候只有跳1级1种跳法，有2级时有每次1级1级跳两次和直接跳2级两种跳法，当有3级台阶的时候，我们可以从第2级跳1级到第3级，也可以从第1级跳2级到第3级，所以3级台阶的总跳法，就是1级台阶的总跳法和2级台阶的总跳法的总和，由此我们就发现了一个规律从3级之后的算法为 f(n)=f(n-1)+f(n-2)，发现我们要求得结果符合<strong>斐波那契数列</strong>。所以我们想知道 n 级台阶总共有多少跳法，只要将 n-1 的跳法加上 n-2 的跳法就可以了。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target - <span class="number">1</span>) + JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="怎么使用递归"><a href="#怎么使用递归" class="headerlink" title="怎么使用递归"></a>怎么使用递归</h3><p>我们现在也对递归有一定的了解了，那递归该怎么用呢？其实在上边例子中其实已经给出了答案。首先，我们要通过规律推导出递归的公式，然后找到递归的终止条件，然后把公式转化为代码就很容易了。就比如上边例子中的解题思路中就是这一过程的实现。</p>
<p>有人觉得递归难以理解，可能是走入误区，就像我一开始举得读源码的例子。一定要在脑子里把递归展开，一层一层去调用，然后一层层的返回，试图去弄明白每一个过程，这其实就有点钻牛角尖了，尤其是当一个问题分解成好几个子问题，然后嵌套层数比较多的时候，我们的大脑是没办法把每一个过程都能想出来的。相反计算机却很擅长这种重复的事情，所以我们没必要在大脑中去分解每一个步骤，我们只需要找到规律公式和终止条件，剩下的交给计算就行了。</p>
<h3 id="使用递归需要注意"><a href="#使用递归需要注意" class="headerlink" title="使用递归需要注意"></a>使用递归需要注意</h3><p>在实际程序设计的时候，我们使用递归的时候要注意几个问题。</p>
<h5 id="栈溢出问题"><a href="#栈溢出问题" class="headerlink" title="栈溢出问题"></a>栈溢出问题</h5><p>我们都知道函数调用时会用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行结束才出栈。一般系统栈和虚拟机栈都不是很大，当递归嵌套的次数较多的时候，就会有栈溢出的风险。</p>
<p>所以如果递归的次数比较小的时候我们可以考虑使用递归，否则我们就要考虑其他的方法。</p>
<h5 id="重复计算问题"><a href="#重复计算问题" class="headerlink" title="重复计算问题"></a>重复计算问题</h5><p>还是以跳台阶的例子来说明，假如我们要计算 5 级台阶有多少种跳法，我们用我们推导出来公式来计算，f(5)=f(4)+f(3)，然后我们分别要求 f(4)=f(3)+f(2)，f(3)=f(2)+f(1)，我们可以看到在求解 f(5) 的时候我们计算过 f(3)，而在计算 f(4) 的时候我们又计算了一遍 f(3)，同样 f(2) 也被计算了多次，这就是重复计算的问题。</p>
<p>我们可以用散列表来储存已经计算过的 f(n)，然后在每次计算的时候先去散列表里查有没有被计算过，如果有那么直接使用；如果没有那把计算后的值存到散列表中，这样就能避免重复计算的问题。</p>
<p>我们按这个办法修改一下上边例子的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; resultMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(resultMap.containsKey(target))&#123;</span><br><span class="line">            <span class="keyword">return</span> resultMap.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = JumpFloor(target - <span class="number">1</span>) + JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">        resultMap.put(target, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h5><p>由于多层递归的嵌套，所以会多次调用函数，当次数达到一定数量的时候，就会有很高的时间成本。在空间复杂度上，因为递归每调用一次就会在栈中保存一次现场数据，所以每次都要产生这种额外的开销。</p>
<h2 id="所以，虽然递归的代码看上去非常简洁，但是也会有很多问题，我们在实际使用的时候一定要注意递归可能会带来的问题。"><a href="#所以，虽然递归的代码看上去非常简洁，但是也会有很多问题，我们在实际使用的时候一定要注意递归可能会带来的问题。" class="headerlink" title="所以，虽然递归的代码看上去非常简洁，但是也会有很多问题，我们在实际使用的时候一定要注意递归可能会带来的问题。"></a>所以，虽然递归的代码看上去非常简洁，但是也会有很多问题，我们在实际使用的时候一定要注意递归可能会带来的问题。</h2><p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/03/30/数据结构与算法系列——队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/数据结构与算法系列——队列/" itemprop="url">数据结构与算法——队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-30T21:17:00+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h4><p>队列也是一种操作受限制的线性表，只允许在表的前端进行删除，也就是出队，而在表的后端进行插入，即入队。</p>
<p>举一个生活中常见的例子，我们经常会遇到排队办事，先来的排在前边先办理，后来的排在后边，不允许插队。<strong>先进先出</strong>，这就是典型的队列。</p>
<h4 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h4><p>队列的概念很容易理解，操作也比较简单，很容易掌握。</p>
<p>跟栈一样，队列也能用数组和链表来实现，用数组实现的队列叫顺序队列，用链表实现的队列叫链式队列。</p>
<p>下面我们先来看一下用数组的实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String item = items[head++];</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列的数组实现比栈的实现稍微复杂一点点，队列需要两个指针，一个指向队头的 head 指针，一个指向队尾的 tail 指针。同样老办法，我们用画图来更清楚的了解一下这个过程。<br><img src="https://upload-images.jianshu.io/upload_images/944288-59945230389fb66b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果这个时候我们调用一次出队，那么 head 指针就指向 1 的位置，并把 0 的位置的元素移除出队。如图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-bb0f9e854b00d919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果这个时候插入一个新的元素，那么 tail 指针就指向 5 的位置，然后把新的元素放到 4 的位置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-d1b71c750f434476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们通过图可以看到，这种实现方法有一个缺点，那就是随着我们不断的入队操作，等到 tail 指向最后一位的时候就没有办法接受新的元素入队了，即使前边有空闲的空间没有元素。所以我们来优化一下我们的代码，当 tail 等于数组的长度 n 的时候，这个时候如果再有新的元素入队，我们就看数组前边是不是有空闲的空间，如果有我们就把队列的元素整体向前移动几个单位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i&lt;tail;i++)&#123;</span><br><span class="line">                items[i-head] = items[I];</span><br><span class="line">            &#125;</span><br><span class="line">            tail -= head;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String item = items[head++];</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老办法，画图来展示这一过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-8f3e88fcc9487990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样就不会有空间的浪费了，但是还有个问题就是数组不能动态扩展，数组满了之后就不能再入队新的元素了，我们来再来修改一下让数组支持动态扩展。当数组满了的时候我们重新申请一个新的数组，长度为原数组的两倍，然后把原数组的元素移到新数组里，然后再进行入队操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String[] newItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="number">0</span>)&#123;</span><br><span class="line">                newItems = <span class="keyword">new</span> String[<span class="number">2</span>*n];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tail;i++)&#123;</span><br><span class="line">                    newItems[i] = items[I];</span><br><span class="line">                &#125;</span><br><span class="line">                items = newItems;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">                    items[i - head] = items[I];</span><br><span class="line">                &#125;</span><br><span class="line">                tail -= head;</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String item = items[head++];</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，上图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-7b7736d9cb72716f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>还有一种特殊的数组实现是循环队列，当 tail == n 的时候我们不迁移数组的元素，而是去看数组下标为 0 的位置为不为空，如果为空的话我们直接入队新的元素，tail 就等于 1 。我们来看一下代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CycleArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">        <span class="comment">//数组满了</span></span><br><span class="line">        <span class="keyword">if</span>((tail+<span class="number">1</span>)%n == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail = (tail+<span class="number">1</span>)%n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String str = items[head];</span><br><span class="line">        head = (head+<span class="number">1</span>)%n;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下边我们来看一下队列的链表实现，同样我们需要两个指针，head 指向链表第一个结点，tail 指向链表最后一个结点。入队时 tail-&gt;next=new_node，tail=tail-&gt;next。出队时 head=head-&gt;next。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNodeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode head;</span><br><span class="line">    <span class="keyword">private</span> ListNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(val, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(tail == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String string = head.val;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String val;</span><br><span class="line">        <span class="keyword">private</span> ListNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(String x, ListNode next)</span> </span>&#123;</span><br><span class="line">            val = x;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">GetValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h4><p>前边将的都是一些基本的理论知识，那队列在实际的项目中都在什么情况下使用呢？阻塞队列和并发队列应用的比较广泛。</p>
<ul>
<li>阻塞队列<br>阻塞队列实际就是在队列的基础上加上了阻塞操作，当队列为空时，出队操作就会被阻塞，因为队列里没有数据，直到队列里有数据之后才能返回；当队列满的时候，入队操作就会被阻塞，直到队列中有空闲的空间时再执行入队操作。<br>我们可以用阻塞队列很容易的实现一个”生产者-消费者“模型，这样我们可以有效的控制生产和消费的速度。当生产者生产的过快时，队列很快就满了，这个时候生产者就阻塞等待，直到消费者消费了，生产者才会被唤醒继续生产。反之消费者消费过快时也同样被阻塞。不仅如此，我们还可以通过调整生产者和消费者的个数，来实现生产和消费的供需平衡。</li>
<li>并发队列<br>在多线程应用中，多个线程同时操作队列，就会存在线程安全问题，处理这个问题的队列我们称为并发队列。最简答的方法就是在入队和出队的时候加锁，保证同时只有一个线程执行队列的入队或出队，但是这样以来就会大大降低线程的并发度。<br>我们可以用上边提到的数组实现的循环队列来解决这个问题，利用 CAS 的原子操作，可以实现非常高效的并发队列。因此，循环队列比链式队列应用的更为广泛。</li>
</ul>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/03/23/数据结构与算法系列--十大排序（附动态图解）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/数据结构与算法系列--十大排序（附动态图解）/" itemprop="url">数据结构与算法——十大排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-23T12:39:00+08:00">
                2019-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文转自公众号 「程序员私房菜 」</p>
</blockquote>
<p>一直有写一篇关于排序算法文章的打算，直到我看到了这一篇，我放弃了自己写的打算，因为这篇写的太经典了。这里强烈推荐给大家。</p>
<hr>
<p>之前的一篇 <a href="http://mp.weixin.qq.com/s?__biz=MzAwMjk5Mjk3Mw==&amp;mid=2247484373&amp;idx=1&amp;sn=a0ed7fa40b63eb7c5282ebe9c361b612&amp;chksm=9ac0bdf7adb734e10224a0da460d6528f45473815a12be5701e04af7eb063206259ad572ebc3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">几张动态图清晰展示常用数据结构及其设计原理</a> 发出来之后反响不错，这次来个<strong>动图排序算法大全</strong>。数据结构与算法，算是齐了！</p>
<p><strong>本文将采取动态图 + 文字描述 + Java代码实现来讲解以下十大排序算法：</strong></p>
<ol>
<li><p>冒泡排序</p>
</li>
<li><p>选择排序</p>
</li>
<li><p>插入排序</p>
</li>
<li><p>希尔排序</p>
</li>
<li><p>归并排序</p>
</li>
<li><p>快速排序</p>
</li>
<li><p>堆排序</p>
</li>
<li><p>计数排序</p>
</li>
<li><p>桶排序</p>
</li>
<li><p>基数排序</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-e6fa6ef935ccb598?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="0、排序算法说明"><a href="#0、排序算法说明" class="headerlink" title="0、排序算法说明"></a>0、排序算法说明</h3><h4 id="0-1-排序的定义"><a href="#0-1-排序的定义" class="headerlink" title="0.1 排序的定义"></a>0.1 <strong>排序的定义</strong></h4><p>对一序列对象根据某个关键字进行排序。</p>
<p><strong>0.2 术语说明</strong></p>
<ul>
<li><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p>
</li>
<li><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
</li>
<li><p><strong>内排序</strong>：所有排序操作都在内存中完成；</p>
</li>
<li><p><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
</li>
<li><p><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</p>
</li>
<li><p><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</p>
</li>
</ul>
<h4 id="0-3-算法总结（这张图值得你收藏）"><a href="#0-3-算法总结（这张图值得你收藏）" class="headerlink" title="0.3 算法总结（这张图值得你收藏）"></a>0.3 算法总结（这张图值得你收藏）</h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-97f4cc0d8f8f1d22?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>0.4 图片名词解释：</strong></p>
<ul>
<li><p>n: 数据规模</p>
</li>
<li><p>k: “桶”的个数</p>
</li>
<li><p>In-place: 占用常数内存，不占用额外内存</p>
</li>
<li><p>Out-place: 占用额外内存</p>
</li>
</ul>
<h4 id="0-5-算法分类"><a href="#0-5-算法分类" class="headerlink" title="0.5 算法分类"></a>0.5 算法分类</h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-35fcfb73bd77bf2d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="0-6-比较和非比较的区别"><a href="#0-6-比较和非比较的区别" class="headerlink" title="0.6 比较和非比较的区别"></a>0.6 比较和非比较的区别</h4><p>常见的<strong>快速排序、归并排序、堆排序、冒泡排序</strong>等属于<strong>比较排序</strong>。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong></p>
<p>在<strong>冒泡排序</strong>之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在<strong>归并排序、快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为logN次，所以时间复杂度平均<strong>O(nlogn)</strong>。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，<strong>比较排序适用于一切需要排序的情况。</strong></p>
<p><strong>计数排序、基数排序、桶排序</strong>则属于<strong>非比较排序</strong>。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度<strong>O(n)</strong>。<br><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p>
<hr>
<p>1、冒泡排序（Bubble Sort）</p>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p>
<h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个；</p>
</li>
<li><p>重复步骤1~3，直到排序完成。</p>
</li>
</ul>
<p><strong>1.2 动图演示</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-50a0ad72a0fd49da?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 冒泡排序</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] bubbleSort(int[] array) &#123;</span><br><span class="line">   if (array.length == 0)</span><br><span class="line">	   return array;</span><br><span class="line">   for (int i = 0; i &lt; array.length; i++)</span><br><span class="line">	   for (int j = 0; j &lt; array.length - 1 - i; j++)</span><br><span class="line">		   if (array[j + 1] &lt; array[j]) &#123;</span><br><span class="line">			   int temp = array[j + 1];</span><br><span class="line">			   array[j + 1] = array[j];</span><br><span class="line">			   array[j] = temp;</span><br><span class="line">		   &#125;</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="这段代码还可以继续优化哦，具体可以看这篇文章：美团面试，我竟然输给了冒泡排序。。。"><a href="#这段代码还可以继续优化哦，具体可以看这篇文章：美团面试，我竟然输给了冒泡排序。。。" class="headerlink" title="这段代码还可以继续优化哦，具体可以看这篇文章：美团面试，我竟然输给了冒泡排序。。。"></a>这段代码还可以继续优化哦，具体可以看这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzAwMjk5Mjk3Mw==&amp;mid=2247484405&amp;idx=1&amp;sn=cb1746c407d8db9ec3c7ee32c6fbbf09&amp;chksm=9ac0bdd7adb734c1d58d03ad2099e4732488f69be635eb7651f5c87c0054b6589b85f713f0f3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">美团面试，我竟然输给了冒泡排序。。。</a></h4><h4 id="1-4-算法分析"><a href="#1-4-算法分析" class="headerlink" title="1.4 算法分析"></a>1.4 <strong>算法分析</strong></h4><p><strong>最佳情况：T(n) = O(n)   最差情况：T(n) = O(n<sup>2</sup>)   平均情况：T(n) = O(n<sup>2</sup>)</strong></p>
<h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>表现<strong>最稳定的排序算法之一</strong>，因为<strong>无论什么数据进去都是O(n2)的时间复杂度</strong>，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li><p>初始状态：无序区为R[1..n]，有序区为空；</p>
</li>
<li><p>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p>
</li>
<li><p>n-1趟结束，数组有序化了。</p>
</li>
</ul>
<h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-155171711dd864b3?imageMogr2/auto-orient/strip" alt="image"></p>
<p>2.3 代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 选择排序</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] selectionSort(int[] array) &#123;</span><br><span class="line">   if (array.length == 0)</span><br><span class="line">	   return array;</span><br><span class="line">   for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">	   int minIndex = i;</span><br><span class="line">	   for (int j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">		   if (array[j] &lt; array[minIndex]) //找到最小的数</span><br><span class="line">			   minIndex = j; //将最小数的索引保存</span><br><span class="line">	   &#125;</span><br><span class="line">	   int temp = array[minIndex];</span><br><span class="line">	   array[minIndex] = array[i];</span><br><span class="line">	   array[i] = temp;</span><br><span class="line">   &#125;</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 <strong>算法分析</strong></h4><p><strong>最佳情况：T(n) = O(n<sup>2</sup>)  最差情况：T(n) = O(n<sup>2</sup>)  平均情况：T(n) = O(n<sup>2</sup>)</strong></p>
<h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li><p>从第一个元素开始，该元素可以认为已经被排序；</p>
</li>
<li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p>
</li>
<li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p>
</li>
<li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p>
</li>
<li><p>将新元素插入到该位置后；</p>
</li>
<li><p>重复步骤2~5。</p>
</li>
</ul>
<h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p>1<br><img src="http://upload-images.jianshu.io/upload_images/944288-7ebb3206a6766e7a?imageMogr2/auto-orient/strip" alt="image"></p>
<p>2.更直观点</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-2553d3eda77353ea?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 插入排序</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] insertionSort(int[] array) &#123;</span><br><span class="line">   if (array.length == 0)</span><br><span class="line">	   return array;</span><br><span class="line">   int current;</span><br><span class="line">   for (int i = 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line">	   current = array[i + 1];</span><br><span class="line">	   int preIndex = i;</span><br><span class="line">	   while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">		   array[preIndex + 1] = array[preIndex];</span><br><span class="line">		   preIndex--;</span><br><span class="line">	   &#125;</span><br><span class="line">	   array[preIndex + 1] = current;</span><br><span class="line">   &#125;</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.4 <strong>算法分析</strong></p>
<p><strong>最佳情况：T(n) = O(n)   最坏情况：T(n) = O(n<sup>2</sup>)   平均情况：T(n) = O(n<sup>2</sup>)</strong></p>
<h3 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n<sup>2</sup>）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p>
<h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，<strong>{n/2,(n/2)/2…1}</strong>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li><p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</p>
</li>
<li><p>按增量序列个数k，对序列进行k 趟排序；</p>
</li>
<li><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ul>
<h4 id="4-2-1-动图演示"><a href="#4-2-1-动图演示" class="headerlink" title="4.2.1 动图演示"></a>4.2.1 动图演示</h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-4377c88b8e991363?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="4-2-2-过程演示"><a href="#4-2-2-过程演示" class="headerlink" title="4.2.2 过程演示"></a>4.2.2 过程演示</h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-e5b1c837e770abab?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 希尔排序</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] ShellSort(int[] array) &#123;</span><br><span class="line">   int len = array.length;</span><br><span class="line">   int temp, gap = len / 2;</span><br><span class="line">   while (gap &gt; 0) &#123;</span><br><span class="line">	   for (int i = gap; i &lt; len; i++) &#123;</span><br><span class="line">		   temp = array[i];</span><br><span class="line">		   int preIndex = i - gap;</span><br><span class="line">		   while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class="line">			   array[preIndex + gap] = array[preIndex];</span><br><span class="line">			   preIndex -= gap;</span><br><span class="line">		   &#125;</span><br><span class="line">		   array[preIndex + gap] = temp;</span><br><span class="line">	   &#125;</span><br><span class="line">	   gap /= 2;</span><br><span class="line">   &#125;</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p><strong>最佳情况：T(n) = O(nlog<sub>2</sub> n)  最坏情况：T(n) = O(nlog<sub>2</sub> n)  平均情况：T(n) =O(nlog<sub>2</sub>n)　</strong></p>
<h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><ul>
<li><p>把长度为n的输入序列分成两个长度为n/2的子序列；</p>
</li>
<li><p>对这两个子序列分别采用归并排序；</p>
</li>
<li><p>将两个排序好的子序列合并成一个最终的排序序列。</p>
</li>
</ul>
<h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p>1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-a14c790131329910?imageMogr2/auto-orient/strip" alt="image"></p>
<p>2</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-60e8586fd6430d03?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 归并排序</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] MergeSort(int[] array) &#123;</span><br><span class="line">   if (array.length &lt; 2) return array;</span><br><span class="line">   int mid = array.length / 2;</span><br><span class="line">   int[] left = Arrays.copyOfRange(array, 0, mid);</span><br><span class="line">   int[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">   return merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 归并排序——将两段排序好的数组结合成一个排序数组</span><br><span class="line">*</span><br><span class="line">* @param left</span><br><span class="line">* @param right</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] merge(int[] left, int[] right) &#123;</span><br><span class="line">   int[] result = new int[left.length + right.length];</span><br><span class="line">   for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) &#123;</span><br><span class="line">	   if (i &gt;= left.length)</span><br><span class="line">		   result[index] = right[j++];</span><br><span class="line">	   else if (j &gt;= right.length)</span><br><span class="line">		   result[index] = left[i++];</span><br><span class="line">	   else if (left[i] &gt; right[j])</span><br><span class="line">		   result[index] = right[j++];</span><br><span class="line">	   else</span><br><span class="line">		   result[index] = left[i++];</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5. 4 算法分析"></a>5. 4 算法分析</h4><p><strong>最佳情况：T(n) = O(n)  最差情况：T(n) = O(nlogn)  平均情况：T(n) = O(nlogn)</strong></p>
<h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><p>从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong>）；</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ul>
<h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p>1 欢快点的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-2a4cf0575e6934a1?imageMogr2/auto-orient/strip" alt="image"></p>
<p>2 正经点的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-d25957943b29c8b1?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 快速排序方法</span><br><span class="line">* @param array</span><br><span class="line">* @param start</span><br><span class="line">* @param end</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] QuickSort(int[] array, int start, int end) &#123;</span><br><span class="line">   if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null;</span><br><span class="line">   int smallIndex = partition(array, start, end);</span><br><span class="line">   if (smallIndex &gt; start)</span><br><span class="line">	   QuickSort(array, start, smallIndex - 1);</span><br><span class="line">   if (smallIndex &lt; end)</span><br><span class="line">	   QuickSort(array, smallIndex + 1, end);</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 快速排序算法——partition</span><br><span class="line">* @param array</span><br><span class="line">* @param start</span><br><span class="line">* @param end</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int partition(int[] array, int start, int end) &#123;</span><br><span class="line">   int pivot = (int) (start + Math.random() * (end - start + 1));</span><br><span class="line">   int smallIndex = start - 1;</span><br><span class="line">   swap(array, pivot, end);</span><br><span class="line">   for (int i = start; i &lt;= end; i++)</span><br><span class="line">	   if (array[i] &lt;= array[end]) &#123;</span><br><span class="line">		   smallIndex++;</span><br><span class="line">		   if (i &gt; smallIndex)</span><br><span class="line">			   swap(array, i, smallIndex);</span><br><span class="line">	   &#125;</span><br><span class="line">   return smallIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 交换数组内两个元素</span><br><span class="line">* @param array</span><br><span class="line">* @param i</span><br><span class="line">* @param j</span><br><span class="line">*/</span><br><span class="line">public static void swap(int[] array, int i, int j) &#123;</span><br><span class="line">   int temp = array[i];</span><br><span class="line">   array[i] = array[j];</span><br><span class="line">   array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-算法分析"><a href="#6-4-算法分析" class="headerlink" title="6.4 算法分析"></a>6.4 算法分析</h4><p><strong>最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n<sup>2</sup>)   平均情况：T(n) = O(nlogn)　</strong></p>
<h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul>
<li><p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li><p>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</p>
</li>
<li><p>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
</li>
</ul>
<h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p>1 欢乐点的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-dbe27d8be2f69e0b?imageMogr2/auto-orient/strip" alt="image"></p>
<p>2 正经点的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-5213976b822eed00?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><p>注意：这里用到了完全二叉树的部分性质。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//声明全局变量，用于记录数组array的长度；</span><br><span class="line">static int len;</span><br><span class="line">/**</span><br><span class="line">* 堆排序算法</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] HeapSort(int[] array) &#123;</span><br><span class="line">   len = array.length;</span><br><span class="line">   if (len &lt; 1) return array;</span><br><span class="line">   //1.构建一个最大堆</span><br><span class="line">   buildMaxHeap(array);</span><br><span class="line">   //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span><br><span class="line">   while (len &gt; 0) &#123;</span><br><span class="line">	   swap(array, 0, len - 1);</span><br><span class="line">	   len--;</span><br><span class="line">	   adjustHeap(array, 0);</span><br><span class="line">   &#125;</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 建立最大堆</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">*/</span><br><span class="line">public static void buildMaxHeap(int[] array) &#123;</span><br><span class="line">   //从最后一个非叶子节点开始向上构造最大堆</span><br><span class="line">   for (int i = (len - 1) / 2; i &gt;= 0; i--) &#123;</span><br><span class="line">	   adjustHeap(array, i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 调整使之成为最大堆</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">* @param i</span><br><span class="line">*/</span><br><span class="line">public static void adjustHeap(int[] array, int i) &#123;</span><br><span class="line">   int maxIndex = i;</span><br><span class="line">   //如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span><br><span class="line">   if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])</span><br><span class="line">	   maxIndex = i * 2;</span><br><span class="line">   //如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span><br><span class="line">   if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])</span><br><span class="line">	   maxIndex = i * 2 + 1;</span><br><span class="line">   //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span><br><span class="line">   if (maxIndex != i) &#123;</span><br><span class="line">	   swap(array, maxIndex, i);</span><br><span class="line">	   adjustHeap(array, maxIndex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-算法分析"><a href="#7-4-算法分析" class="headerlink" title="7.4 算法分析"></a>7.4 算法分析</h4><p><strong>最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)</strong></p>
<h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul>
<li><p>找出待排序的数组中最大和最小的元素；</p>
</li>
<li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</p>
</li>
<li><p>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</p>
</li>
<li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
</li>
</ul>
<h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-2c9492558e2d7abb?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 计数排序</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] CountingSort(int[] array) &#123;</span><br><span class="line">   if (array.length == 0) return array;</span><br><span class="line">   int bias, min = array[0], max = array[0];</span><br><span class="line">   for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">	   if (array[i] &gt; max)</span><br><span class="line">		   max = array[i];</span><br><span class="line">	   if (array[i] &lt; min)</span><br><span class="line">		   min = array[i];</span><br><span class="line">   &#125;</span><br><span class="line">   bias = 0 - min;</span><br><span class="line">   int[] bucket = new int[max - min + 1];</span><br><span class="line">   Arrays.fill(bucket, 0);</span><br><span class="line">   for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">	   bucket[array[i] + bias]++;</span><br><span class="line">   &#125;</span><br><span class="line">   int index = 0, i = 0;</span><br><span class="line">   while (index &lt; array.length) &#123;</span><br><span class="line">	   if (bucket[i] != 0) &#123;</span><br><span class="line">		   array[index] = i - bias;</span><br><span class="line">		   bucket[i]--;</span><br><span class="line">		   index++;</span><br><span class="line">	   &#125; else</span><br><span class="line">		   i++;</span><br><span class="line">   &#125;</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<p><strong>最佳情况：T(n) = O(n+k)  最差情况：T(n) = O(n+k)  平均情况：T(n) = O(n+k)</strong></p>
<h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul>
<li><p>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</p>
</li>
<li><p>遍历输入数据，并且把数据一个一个放到对应的桶里去；</p>
</li>
<li><p>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</p>
</li>
<li><p>从不是空的桶里把排好序的数据拼接起来。 </p>
</li>
</ul>
<p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p>
<h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-18b751eb53a0a547?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 桶排序</span><br><span class="line">*</span><br><span class="line">* @param array</span><br><span class="line">* @param bucketSize</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) &#123;</span><br><span class="line">   if (array == null || array.size() &lt; 2)</span><br><span class="line">	   return array;</span><br><span class="line">   int max = array.get(0), min = array.get(0);</span><br><span class="line">   // 找到最大值最小值</span><br><span class="line">   for (int i = 0; i &lt; array.size(); i++) &#123;</span><br><span class="line">	   if (array.get(i) &gt; max)</span><br><span class="line">		   max = array.get(i);</span><br><span class="line">	   if (array.get(i) &lt; min)</span><br><span class="line">		   min = array.get(i);</span><br><span class="line">   &#125;</span><br><span class="line">   int bucketCount = (max - min) / bucketSize + 1;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);</span><br><span class="line">   ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();</span><br><span class="line">   for (int i = 0; i &lt; bucketCount; i++) &#123;</span><br><span class="line">	   bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   for (int i = 0; i &lt; array.size(); i++) &#123;</span><br><span class="line">	   bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">   &#125;</span><br><span class="line">   for (int i = 0; i &lt; bucketCount; i++) &#123;</span><br><span class="line">	   if (bucketCount == 1)</span><br><span class="line">		   bucketSize--;</span><br><span class="line">	   ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">	   for (int j = 0; j &lt; temp.size(); j++)</span><br><span class="line">		   resultArr.add(temp.get(j));</span><br><span class="line">   &#125;</span><br><span class="line">   return resultArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p>
<p><strong>最佳情况：T(n) = O(n+k)   最差情况：T(n) = O(n+k)   平均情况：T(n) = O(n<sup>2</sup>)　</strong></p>
<h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul>
<li><p>取得数组中的最大数，并取得位数；</p>
</li>
<li><p>arr为原始数组，从最低位开始取每个位组成radix数组；</p>
</li>
<li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
</li>
</ul>
<h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="http://upload-images.jianshu.io/upload_images/944288-503476b174097dbc?imageMogr2/auto-orient/strip" alt="image"></p>
<h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 基数排序</span><br><span class="line">* @param array</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static int[] RadixSort(int[] array) &#123;</span><br><span class="line">   if (array == null || array.length &lt; 2)</span><br><span class="line">	   return array;</span><br><span class="line">   // 1.先算出最大数的位数；</span><br><span class="line">   int max = array[0];</span><br><span class="line">   for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">	   max = Math.max(max, array[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   int maxDigit = 0;</span><br><span class="line">   while (max != 0) &#123;</span><br><span class="line">	   max /= 10;</span><br><span class="line">	   maxDigit++;</span><br><span class="line">   &#125;</span><br><span class="line">   int mod = 10, div = 1;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">   for (int i = 0; i &lt; 10; i++)</span><br><span class="line">	   bucketList.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">   for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) &#123;</span><br><span class="line">	   for (int j = 0; j &lt; array.length; j++) &#123;</span><br><span class="line">		   int num = (array[j] % mod) / div;</span><br><span class="line">		   bucketList.get(num).add(array[j]);</span><br><span class="line">	   &#125;</span><br><span class="line">	   int index = 0;</span><br><span class="line">	   for (int j = 0; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">		   for (int k = 0; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">			   array[index++] = bucketList.get(j).get(k);</span><br><span class="line">		   bucketList.get(j).clear();</span><br><span class="line">	   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p><strong>最佳情况：T(n) = O(n <em> k)   最差情况：T(n) = O(n </em> k)   平均情况：T(n) = O(n * k)</strong></p>
<p>基数排序有两种方法：</p>
<p>MSD 从高位开始进行排序 LSD 从低位开始进行排序 </p>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li><p>基数排序：根据键值的每位数字来分配桶</p>
</li>
<li><p>计数排序：每个桶只存储单一键值</p>
</li>
<li><p>桶排序：每个桶存储一定范围的数值</p>
</li>
</ul>
<p>本文参考自： </p>
<p><a href="http://www.cnblogs.com/guoyaohua/p/8600214.html" target="_blank" rel="noopener">http://www.cnblogs.com/guoyaohua/p/8600214.html</a> </p>
<p>www.cricode.com/3212.html</p>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/03/09/数据结构与算法系列——栈/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/数据结构与算法系列——栈/" itemprop="url">数据结构与算法——栈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-09T22:53:00+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h4><p>栈是一种运算受限制的线性表，只允许在表的一端进行插入和删除操作。这一端被称为栈顶，另一端被称为栈底。向一个栈中插入新数据叫做进栈、入栈或者压栈，是把新元素放到栈顶上边，使其成为新的栈顶元素；删除数据叫做出栈或者退栈，就是把栈顶的元素删掉，使其下边的元素称为新的栈顶元素。</p>
<p>举一个容易理解的例子，就是有一摞盘子，我们用的时候从上往下一个一个取，放的时候都是从下往上一个一个放，一般不从中间取或者放。这种先进后出，后进先出的数据结构就是栈。</p>
<p>这种操作受限的数据结构在什么情况下用呢，我们为什么不能用操作更为方便的数组或者链表呢。当某个数据只涉及在一端的插入和删除数据，并满足先进后出，后进先出的特点，我们就可以用栈这种数据结构，而数组和链表因为操作的灵活性，有时候会使一些数据不可控，更容易出现错误。</p>
<h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>从功能上，我们是可以用数组和链表来实现栈，只要实现栈的入栈和出栈的操作，即从栈顶插入新的数据，从栈顶删除数据。用数组实现的栈叫做顺序栈，用链表实现的栈叫做链表栈。下边我们分别看一下用数组和链表实现栈的代码。这里用Java代码实现。</p>
<ul>
<li>数组实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//基于数组实现的栈</span><br><span class="line">public class ArrayStack&#123;</span><br><span class="line"></span><br><span class="line">    //数组</span><br><span class="line">    private String[] items;</span><br><span class="line">    //栈的大小</span><br><span class="line">    private int length;</span><br><span class="line">    //栈中元素的个数</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ArrayStack(int len)&#123;</span><br><span class="line">        items = new String[len];</span><br><span class="line">        length = len;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public boolean Push(String x)&#123;</span><br><span class="line">        //数组空间不足</span><br><span class="line">        if(count == length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        items[count] = x;</span><br><span class="line">        count++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public String Pop()&#123;</span><br><span class="line">        //栈为空</span><br><span class="line">        if(count == 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        String tem = items[count-1];</span><br><span class="line">        count--;</span><br><span class="line">        return tem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//基于链表实现的栈</span><br><span class="line">public class ListNodeStack &#123;</span><br><span class="line"></span><br><span class="line">    private ListNode top;</span><br><span class="line"></span><br><span class="line">    //进栈</span><br><span class="line">    public void Push(int val) &#123;</span><br><span class="line">        ListNode node = new ListNode(val, null);</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            top = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.next = top;</span><br><span class="line">            top = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int Pop() &#123;</span><br><span class="line">        if (top == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int val = top.val;</span><br><span class="line">        top = top.next;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //链表的结点</span><br><span class="line">    class ListNode &#123;</span><br><span class="line">        private int val;</span><br><span class="line">        private ListNode next;</span><br><span class="line"></span><br><span class="line">        public ListNode(int x, ListNode next) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int GetValue() &#123;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上边代码用数组实现的栈是一个固定大小的栈，当栈满了之后就没法办插入新的数据了，那么我们能不能用数组实现一个动态扩容的栈呢？前边我们将数组的时候说过，实现一个动态扩容的数组，是在数组满了的时候，我们重新创建一个大小为原来两倍的数组，然后把原来数组的数据拷贝到新的数组中，所以我们也可以用这个方法来实现一个动态扩容的栈。我们看一下代码实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//基于数组实现的栈</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line"></span><br><span class="line">    //数组</span><br><span class="line">    private String[] items;</span><br><span class="line">    //栈的大小</span><br><span class="line">    private int length;</span><br><span class="line">    //栈中元素的个数</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ArrayStack(int len) &#123;</span><br><span class="line">        items = new String[len];</span><br><span class="line">        length = len;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void Push(String x) &#123;</span><br><span class="line">        //数组空间不足</span><br><span class="line">        if (count == length) &#123;</span><br><span class="line">            DilatationArray();</span><br><span class="line">        &#125;</span><br><span class="line">        items[count] = x;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public String Pop() &#123;</span><br><span class="line">        //栈为空</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        String tem = items[count - 1];</span><br><span class="line">        count--;</span><br><span class="line">        return tem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //数组扩容</span><br><span class="line">    private void DilatationArray() &#123;</span><br><span class="line">        String[] newArray = new String[length * 2];</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            newArray[i] = items[I];</span><br><span class="line">        &#125;</span><br><span class="line">        items = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="栈的实际应用"><a href="#栈的实际应用" class="headerlink" title="栈的实际应用"></a>栈的实际应用</h4><ol>
<li>在函数调用中的应用</li>
</ol>
<p>在Java的虚拟机中有一个内存区域被称为虚拟机栈。每个方法在执行的时候都会创建一个“栈帧”。用来存储局部变量表（包括参数）、操作栈、动态链接、方法出口等信息。每个方法从调用到结束就会有栈帧在虚拟机栈中入栈和出栈。</p>
<p>举一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AddClass&#123;</span><br><span class="line">    public int Main()&#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        int b = 5;</span><br><span class="line">        int c = 0;</span><br><span class="line">        a = Add(2, 3);</span><br><span class="line">        c = a + b;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int Add(int x, int y)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        sum = x + y;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中我们看到 Main 方法中首先声明了几个变量，然后调用了 Add 方法，然后经过一些运算，最后返回一个值。我们画图来更直观的看一下这个过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-904d7866765f7b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol>
<li>在表达式求值中的应用</li>
</ol>
<p>编辑器的表达式求值的过程，就是用栈来实现的。我们举一个简单的四则运算的表达式的求值过程来看一下。例如：1+2*3-4/2。编辑器是怎么计算来得到最后的值呢。</p>
<p>这个求值过程，编辑器是用两个栈来实现的，一个保存数字的栈，一个保存运算符号的栈。我们从左向右遍历表达式，当遇到数字的时候把它压入数字栈，当遇到运算符号的时候，就与运算符栈的栈顶的运算符比较，如果比栈顶的运算符优先级高，就直接压入运算符栈，如果比栈顶的运算符优先级低或者相同，那么就从运算符栈取出栈顶运算符号，从数字栈中取出两个数字进行计算，然后把结果压入数字栈，然后继续比较，依次类推，知道最后。</p>
<p>我们为了更形象的理解，也用画图的方式来展示一下这个过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-8f2e2282f516193b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol>
<li>在各种前进后退操作中的应用</li>
</ol>
<p>我们在各中编辑器的撤销和恢复操作，浏览器中的前进和后退操作，都是用栈来实现的。</p>
<p>我们用两个栈 A 和 B，当我们执行操作的时候把我们的每一个操作依次压入 A 栈中，当我们执行后退的操作时，依次从 A 栈中取出，然后压入 B 栈中，当执行前进操作的时候，依次从 B 栈中取出，然后压入 A 栈中。</p>
<p>比如我们依次执行了 a，b，c 操作，我们依次把 a，b，c 压入 A 栈。如图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-17935f3c72e9993c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>假如我们现在想要撤销 c 和 b 操作。那么它就是这样的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-516a2414ce0db685.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>假如我又想恢复操作 b<br><img src="https://upload-images.jianshu.io/upload_images/944288-3aac06bb479fed65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这个时候我继续执行新的操作 d，那么无论前进后退我们都无法再回到操作 c 了，所以我们应该清空 B 栈。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://upload-images.jianshu.io/upload_images/944288-485bb2f5e1608a4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></h2><p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/03/03/数据结构与算法系列——链表详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/数据结构与算法系列——链表详解/" itemprop="url">数据结构与算法——链表详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-03T22:08:00+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上次我们简单的对比了一下数组和链表的区别和各自的优缺点，今天我们来详细看一下链表这个结构。<br>链表的结构五花八门，我们几天主要看一下三种最常用的链表结构：<strong>单链表、双向链表和循环列表</strong>。</p>
<ul>
<li>单链表</li>
</ul>
<p>我们首先来看一下最简单、最常用的单链表。前边我们已经知道链表是通过指针将一些分散的内存块连接到一起。其中，我们把每个内存块叫做链表的一个<strong>结点</strong>。为了将每个结点连接到一起，每个结点不仅存储数据，而且还需要记录下一个结点的地址。我们把这个记录下一个结点的指针称为<strong>后继指针next</strong>。我们通过下边示意图来更形象的了解一下。<br><img src="https://upload-images.jianshu.io/upload_images/944288-b7ed2255d218cbc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中我们可以看到，单链表是单方向顺序的一个线性表。其中有两个结点比较特殊，分别是第一个和最后一个结点。我们通常把第一个结点叫做<strong>头结点</strong>，最后一个结点叫做<strong>尾结点</strong>，头结点用来记录链表的基地址，这样我们就可以遍历得到整个结点，尾结点是最后一个结点，它的指针指向一个空地址<strong>NULL</strong>，这样我们通过判断后继指针next是不是NULL来确定某个结点是不是尾结点。<br>前边我们在<strong>数组和链表</strong>中已经详细介绍了链表的插入和删除，在这里我们不做过多的描述，而是通过示意图的方式更清楚的了解。针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度为O(1)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/944288-a55c33b67fda310f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>双向链表</li>
</ul>
<p>单链表只有一个指针，每个结点都只有一个后继指针next指向下一个结点的地址。而双向链表，顾名思义，它有两个方向，所以每个结点不仅有一个指向下一个结点的后继指针next，还有一个指向前一个结点的<strong>前驱结点prev</strong>。同样我们通过示意图来看一下。<br><img src="https://upload-images.jianshu.io/upload_images/944288-bb9954d01ecdf75f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中我们看到，与单链表相比，双向链表的每个结点还需要存储指向前一个结点的指针，所以，同样多的数据，双向链表比单链表需要更多的存储空间。两个指针虽然比较浪费空间，但是双向链表可以双向遍历，灵活性更高。<br>双向链表在删除、插入结点上更加高效，前边我们讲过单链表的删除和插入操作的时间复杂度为O(1)，但是双向链表的为什么会更高效呢，因为单链表的分析只是理论上得到的，但是实际情况中是不准确的，是需要前提条件的。<br>下面我们分析一下实际情况中的操作。我们先来看插入操作，实际情况中的插入操作可以分为这两种情况：</p>
<ol>
<li>在值等于某个指定值的结点前或者后插入结点</li>
<li>在给定指针后边插入结点</li>
</ol>
<p>对于第一种情况，不管是单链表还是双向链表，都需要从头一个一个遍历直到找到特定值的结点，然后执行插入操作虽然插入的时间复杂度为O(1)，但是遍历的时间复杂度为O(n)，所以在值等于某个指定值的结点前或者后插入结点的时间复杂度为O(n)。<br>对于第二种情况，我们通过给定指针可以直到插入结点的位置，但是我们需要直到给定指针的前驱结点，如果是单链表，我们依然需要通过从头开始遍历找到前驱结点，需要的时间复杂度为O(n)，但是对于双向链表就简单多了，我们只需要通过前驱结点的指针就能得到前驱结点，需要的时间复杂度为O(1)。<br>同理，参照我们上边插入操作的分析，删除结点双向链表同样比单链表灵活得多。<br>还有就是在有序链表中，双向链表的按值查询也比单链表也快一些，因为我们可以记录上次查找的位置x，然后通过比较查询值x的大小来决定向前还是向后，可以比单链表节省时间。<br>通过上边单链表和双向链表的比较，我们有学习了灵位一个非常重要的知识点，那就是<strong>用空间换时间</strong>的思想，当内存空间充足时，如果我们对执行效率有更高的要求，可以用牺牲内存而换取效率的办法，也就是选择空间复杂度相对比较高，但是时间复杂度低的算法或者数据结构（实际应用中，缓存就是利用空间换时间的思想）。相反，如果内存比较紧张，我们就可以用时间换空间的算法或数据结构。</p>
<ul>
<li>循环链表</li>
</ul>
<p>循环链表一种特殊的单链表，与单链表唯一的区别就是，循环链表的尾结点的指针指向头结点而不是指向空地址。如下示意图所示。<br><img src="https://upload-images.jianshu.io/upload_images/944288-b6e38652a161a6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>和单链表相比，循环列表的优点就是从链尾到链头比较方便。比如需要处理的数据具有环形结构特点时，用循环列表就非常合适。虽然单链表也可以实现，但是循环链表的代码要简洁的多。</p>
<h5 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h5><p>我们已经学习了三种简单且最常见的链表，那么链表在实际的应用中是怎么用的呢？一个经典的链表使用场景就是<strong>LRU缓存淘汰法</strong>。<br>缓存的大小有限，但缓存的空间被用满的时候，我们该把哪些数据清除出去呢？LRU缓存淘汰法就是其中的一种策略，把最近最少用的数据清除出去。<br>那用链表怎么实现这个算法呢，下边我们来看一下基于单链表的Java实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">package linked.singlelist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 基于单链表LRU算法（java）</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LRUBaseLinkedList&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 头结点</span><br><span class="line">     */</span><br><span class="line">    private SNode&lt;T&gt; headNode;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链表长度</span><br><span class="line">     */</span><br><span class="line">    private Integer length;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链表容量</span><br><span class="line">     */</span><br><span class="line">    private Integer capacity;</span><br><span class="line"></span><br><span class="line">    public LRUBaseLinkedList(Integer capacity) &#123;</span><br><span class="line">        this.headNode = new SNode&lt;&gt;();</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        this.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(T data) &#123;</span><br><span class="line">        SNode preNode = findPreNode(data);</span><br><span class="line"></span><br><span class="line">        // 链表中存在，删除原数据，再插入到链表的头部</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            deleteElemOptim(preNode);</span><br><span class="line">            intsertElemAtBegin(data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (length &gt;= this.capacity) &#123;</span><br><span class="line">                //删除尾结点</span><br><span class="line">                deleteElemAtEnd();</span><br><span class="line">            &#125;</span><br><span class="line">            intsertElemAtBegin(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除preNode结点下一个元素</span><br><span class="line">     *</span><br><span class="line">     * @param preNode</span><br><span class="line">     */</span><br><span class="line">    private void deleteElemOptim(SNode preNode) &#123;</span><br><span class="line">        SNode temp = preNode.getNext();</span><br><span class="line">        preNode.setNext(temp.getNext());</span><br><span class="line">        temp = null;</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链表头部插入结点</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     */</span><br><span class="line">    private void intsertElemAtBegin(T data) &#123;</span><br><span class="line">        SNode next = headNode.getNext();</span><br><span class="line">        headNode.setNext(new SNode(data, next));</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取查找到元素的前一个结点</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private SNode findPreNode(T data) &#123;</span><br><span class="line">        SNode node = headNode;</span><br><span class="line">        while (node.getNext() != null) &#123;</span><br><span class="line">            if (data.equals(node.getNext().getElement())) &#123;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除尾结点</span><br><span class="line">     */</span><br><span class="line">    private void deleteElemAtEnd() &#123;</span><br><span class="line">        SNode ptr = headNode;</span><br><span class="line">        // 空链表直接返回</span><br><span class="line">        if (ptr.getNext() == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 倒数第二个结点</span><br><span class="line">        while (ptr.getNext().getNext() != null) &#123;</span><br><span class="line">            ptr = ptr.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SNode tmp = ptr.getNext();</span><br><span class="line">        ptr.setNext(null);</span><br><span class="line">        tmp = null;</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void printAll() &#123;</span><br><span class="line">        SNode node = headNode.getNext();</span><br><span class="line">        while (node != null) &#123;</span><br><span class="line">            System.out.print(node.getElement() + &quot;,&quot;);</span><br><span class="line">            node = node.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class SNode&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private T element;</span><br><span class="line"></span><br><span class="line">        private SNode next;</span><br><span class="line"></span><br><span class="line">        public SNode(T element) &#123;</span><br><span class="line">            this.element = element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public SNode(T element, SNode next) &#123;</span><br><span class="line">            this.element = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public SNode() &#123;</span><br><span class="line">            this.next = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public T getElement() &#123;</span><br><span class="line">            return element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setElement(T element) &#123;</span><br><span class="line">            this.element = element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public SNode getNext() &#123;</span><br><span class="line">            return next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setNext(SNode next) &#123;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LRUBaseLinkedList list = new LRUBaseLinkedList();</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            list.add(sc.nextInt());</span><br><span class="line">            list.printAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/02/22/数据结构与算法系列——数组和链表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/数据结构与算法系列——数组和链表/" itemprop="url">数据结构与算法——数组和链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-22T23:21:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="数组的介绍"><a href="#数组的介绍" class="headerlink" title="数组的介绍"></a>数组的介绍</h4><p>在每一种编程语言种，基本都有数组这种数据类型，当然它不仅是一种数据类型，还是一种基础、简单的数据结构。<br>数组的定义是：<strong>数组是一种线性表数据结构，他用一组连续的内存空间，来储存一组相同类型的数据</strong></p>
<h4 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h4><p>数组是一种线性表，线性表就是数据像一条线一样，排列成一条有序的队，每个数据只有前和后两个方向。数组在内存中的储存是连续的，声明数组的时候会在内存中找一块连续的空间，来依次储存数组的每个数据。数组需要预留储存空间，在使用前需要先申请内存的大小，很有可能会浪费空间。数组随机访问效率高，因为在内存中是连续的，所以可以直接访问该地址的数据。但是数组因为连续这一特点使得它的的插入和删除效率低，因为需要把插入和删除位置后边的所有数据后挪或者前移。数组不利于动态扩展，数组一旦定义，长度是固定的，扩展起来比较麻烦，需要重新定义数组。</p>
<h4 id="数组的优点"><a href="#数组的优点" class="headerlink" title="数组的优点"></a>数组的优点</h4><ul>
<li>随机访问性高</li>
<li>查找速度快<h4 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h4></li>
<li>插入和删除效率低</li>
<li>不易于扩展</li>
<li>对内存要求高，需要连续的空间</li>
<li>有可能造成内存的浪费<h4 id="链表的介绍"><a href="#链表的介绍" class="headerlink" title="链表的介绍"></a>链表的介绍</h4>链表也是一种基本的数据结构，它有一系列节点组成，每个节点包括一个数据结构（用来存放各类型的数据），还包括一个指向下一个节点的指针。<h4 id="链表的特点"><a href="#链表的特点" class="headerlink" title="链表的特点"></a>链表的特点</h4>链表和数组一样也是线性表，但是链表在内存中的储存是非连续、非顺序的。每一个数据都保存了一个指针，指向下一个数据的内存地址，这样通过这个指针就可以找到下一个数据，也正是因为是非连续的，所以随机访问和数据的查找比较麻烦，每次都要从头开始依次向后直到找到目标数据为止。但是插入和删除操作比较容易，因为不是连续有序的，所以插入的时候，只需要把前一个数据的指针指向新数据，然后新数据的指针指向后一个数据就可以了，删除的时候只需要把后一个数据告诉前一个数据就可以了，其他的数据都不需要做修改。链表还支持动态扩展，可以随意增加和删除数据。<h4 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h4></li>
<li>插入、删除速度快</li>
<li>内存利用率高，不浪费</li>
<li>易于扩展<h4 id="链表的缺点"><a href="#链表的缺点" class="headerlink" title="链表的缺点"></a>链表的缺点</h4></li>
<li>不能随机访问，查找效率低</li>
</ul>
<p>最后我们用前边学习的时间复杂度来分析数组和链表的操作</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>\</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于已知大小，并且对数据操作读取较多，插入、删除较少，可以直接用数组。由于链表在有时候不能直接储存基本数据类型，所以性能会有一点点的损耗。<br>我们在平时业务逻辑的时候可以直接使用像链表这种容器类，虽然有一点点性能损耗，但影响很小。但如果做底层的开发，对性能要求比较高的时候，直接用数组更为合适。</p>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://caixiaobai.github.io/2019/02/20/数据结构与算法系列——时间、空间复杂度/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KeepUp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeepUp's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/数据结构与算法系列——时间、空间复杂度/" itemprop="url">数据结构与算法——时间、空间复杂度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-20T22:09:00+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据结构和算法本质就是帮我们用最快的时间和最少的空间来执行我们的代码。所以，执行效率是衡量一个算法的非常重要的指标。那如何来计算你的算法代码的执行效率呢？这就需要时间、空间复杂度来分析了。</p>
<p>有人可能会说，我把代码执行一遍，然后通过统计、监控就能知道执行的时间和需要的内存大小。干嘛还需要时间、空间复杂度来分析呢？我都能得到具体需要的时间和内存了，还需要多此一举吗？</p>
<p>首先，这种评估算法效率的方法没有问题，我们还给这种方法起了一个名字，叫<strong>事后统计法</strong>。但是这种方法有很大的局限性。</p>
<p><strong>1. 测试结果受测试环境影响</strong></p>
<p>测试环境的硬件对测试结果有非常大的影响。比如，同样的代码在i7和i5的机器上执行，结果肯定是不同的。还有可能在一台机器上A代码比B代码执行速度要快，我们换另外一台机器却得到相反的结果。</p>
<p><strong>2. 测试结果受数据规模的影响</strong></p>
<p>比如排序算法，原始数据如果有序度不一样，执行的时间就会有很大的差别。原始数据规模的大小不同，也可能会让原来速度快的算法变成速度慢的。</p>
<p>所以我们就需要一个不需要具体的测试数据来测试，就可以大概估算出执行效率的方法，就是时间、空间复杂度分析方法。</p>
<h5 id="大O复杂度表示方法"><a href="#大O复杂度表示方法" class="headerlink" title="大O复杂度表示方法"></a>大O复杂度表示方法</h5><p>我们通过度代码，来估算出它执行所需要的时间，下边来看一段具体的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int Function(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们假设每一行代码执行的时间都是相同的为 t，那么第 3 行执行的时间为 t，第 4 和 6 行执行了 n 次，需要时间为 2n<em>t，总的时间为 (1+2n)</em>t，可以看出来总的代码的执行时间 T(n) 与每行代码的执行次数成正比。</p>
<p>然后我们再来看下边的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int Function(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 1; j &lt;= n; j++</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中在上边的基础上又套了一层 for 循环，第 6 和 8 行执行了 n^2 次，需要的时间为 2n^2 <em> t ,总的需要的时间为 T(n)=(2n^2+2n+1) </em> t </p>
<p>通过上述两个具体的代码例子我们总结出一个公式：</p>
<hr>
<p>T(n)=O(f(n))</p>
<hr>
<p>T(n) 表示代买执行的时间，n 是数据的大小，f(n) 表示代码执行的总次数，O 表示公式中 T(n) 与 f(n) 成正比。这就是大 O 时间复杂度表示法，它实际上并不表示代码具体执行所需要的时间，它表示随着数据规模的变化代码执行时间的变化趋势。</p>
<p>当 n 非常大时，低阶、系数、常量对结果的影响就非常小了，所以我们可以把这几项忽略不记，只保留最高阶的就可以了，所以上边两个例子中 O(1+2n) 就可以记为 O(n)，o(2n^2+2n+1) 就可以记为 O(n^2)。</p>
<p>上边我们知道了怎么用大 O 时间复杂度的表示方法。那么我们如何具体分析一段代码的时间复杂度呢？</p>
<ul>
<li>只关注循环次数最多的一段代码</li>
</ul>
<p>因为大 O 时间复杂度只表示一种变化的趋势，所以我们只需要关心阶数最高的那部分就可以了，低阶、系数、常量我们都可以忽略。以上边第一段代码为例 O(1+2n)，我们忽略掉系数和常量最后就得到了 O(n)。</p>
<ul>
<li>加法法则</li>
</ul>
<p>对于顺序执行的长代码，我们把它分成几部分，分别求出其总时间 T(n) ,然后相加得到总的时间，最后同样忽略低阶、系数、常量部分，保留最高阶的部分然后得出最后的时间复杂度大 O。</p>
<ul>
<li>乘法法则</li>
</ul>
<p>对于逻辑复杂的嵌套代码，我们分别求嵌套内外代码的复杂度，然后相乘得出最终的时间复杂度大 O。</p>
<h5 id="几种常见的时间复杂度分析"><a href="#几种常见的时间复杂度分析" class="headerlink" title="几种常见的时间复杂度分析"></a>几种常见的时间复杂度分析</h5><p>下边列举出常见的时间复杂度量级</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>多项式量级</th>
<th>非多项式量级</th>
</tr>
</thead>
<tbody>
<tr>
<td>常数阶 O(1)</td>
<td>指数阶 O(2^n)</td>
</tr>
<tr>
<td>对数阶 O(logn)</td>
<td>阶乘阶 O(n!)</td>
</tr>
<tr>
<td>线性阶 O(n)</td>
<td></td>
</tr>
<tr>
<td>线性对数阶 O(nlogn)</td>
<td></td>
</tr>
<tr>
<td>k次方阶 O(n^2) O(n^3) O(n^k)</td>
</tr>
</tbody>
</table>
</div>
<p>对于非多项式量级的算法会随着数据规模的增大急剧增加，所以分多项式量级的算法是非常低效的，我们不做过多的介绍。主要来介绍几种常见的多项式量级的时间复杂度。</p>
<ol>
<li>常数阶 O(1)</li>
</ol>
<p>O(1) 只是常量级时间复杂度的表示方式，不是只有一行代码，而是每一段代码的执行时间不随着 n 的数据规模的变大而变长，这样的代码的时间复杂度记为 O(n)。</p>
<ol>
<li>对数阶 O(logn) O(nlogn)</li>
</ol>
<p>对数阶复杂度很常见，但是分析的时候却不容易，下面我们用一段实际的例子来看看对数阶时间复杂度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void Function(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i*2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上边我们总结的方法，我们只需要知道 while 循环的次数，就能得到这段代码的复杂度。从代码中可以看出 i 的值从 1 开始，每循环一次乘以 2，直到 i 的值大于 n 的时候结束，我们得到规律然后把结果列出来，<br>2^0 2^1 2^3 2^4 …… 2^x = n ，然后求得执行的次数 x = logn ,这段代码的时间复杂度就是 O(logn)。</p>
<ol>
<li>O(n+m) O(n*m)</li>
</ol>
<p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模决定，所以我们需要同时考虑两种数据规模对结果的影响，如果是顺序的，那么时间复杂度就为 O(n+m)，如果为嵌套的那么时间复杂度为 O(n*m)。</p>
<h5 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h5><p>理解了上边的时间复杂度的分析方法，空间复杂度的分析也就很简单了。空间复杂度表示算法的存储空间与数据规模之间的增长关系。</p>
<p>同样我们通过一段实际的代码来分析一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void Function(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int[] a = new int[n];</span><br><span class="line">    for(i;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = i*i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到第 3 行代码，我们申请了一个空间存储变量 i ，但是这个是常数阶的，不会随 n 的变化而变化，所以可以忽略，第 4 行我们申请了一个大小为 n 的 int 类型数组，除此之外其余代码没有占用其他的空间，所以这段代码的空间复杂度为 O(n)。</p>
<p>我们常见的空间复杂度有 O(1)、O(n)、O(n^2)，对数阶的空间复杂度一般情况下用不到。所以空间复杂度比时间复杂度容易分析的多，我们也只需要掌握常见的几种就可以了。</p>
<p>最后我们总结一下常见的几种复杂度，执行效率从高到低依次为<br>O(1)&gt;O(logn)&gt;O(n)&gt;o(nlogn)&gt;O(n^2)</p>
<hr>
<p>欢迎关注公众号：「努力给自己看」</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944288-610ecd78a90d550c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号200x200"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">KeepUp</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KeepUp</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
